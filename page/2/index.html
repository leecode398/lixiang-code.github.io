<!DOCTYPE html>
<html lang="en-us">
  <head>
	<meta name="generator" content="Hugo 0.68.3" />
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  
  
  
  
  
  
  <link rel="canonical" href="https://lixiang-code.github.io/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           lee blog
       
  </title>
  <meta name="title" content="lee blog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
    <link href="https://lixiang-code.github.io/index.xml" rel="alternate" type="application/rss+xml" title="lee blog" />
    <link href="https://lixiang-code.github.io/index.xml" rel="feed" type="application/rss+xml" title="lee blog" />
  
  

<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "url": "https:\/\/lixiang-code.github.io\/",
    "name": "lee blog",
    "author": {
        "@type": "Person",
        "name": ""
    },
    "description": "",
}
</script>
 

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://lixiang-code.github.io">lee blog</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="posts/" title="">Posts</a>
                
                <a class="menu-item" href="about-hugo/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://lixiang-code.github.io">lee blog</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="posts/" title="">Posts</a>
                
                <a class="menu-item" href="about-hugo/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
  	
  	
<div class="post-warp">
	<div class="intro">
    
    
    
 
</div>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://lixiang-code.github.io/docker/"></a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 

       			Docker 1.简介 Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=0001-01-01 itemprop="datePublished">January 1, 0001</time>
                </span>
                in
                
        </div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://lixiang-code.github.io/docker%E8%AE%BE%E7%BD%AE%E7%8B%AC%E7%AB%8Bip/"></a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 

       			Docker设置独立IP 
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=0001-01-01 itemprop="datePublished">January 1, 0001</time>
                </span>
                in
                
        </div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://lixiang-code.github.io/gorm/"></a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 

       			GORM 安装 go get -u github.com/jinzhu/gorm 示例 package main import ( &#34;github.com/jinzhu/gorm&#34; _ &#34;github.com/jinzhu/gorm/dialects/sqlite&#34; ) type Product struct { gorm.Model Code string Price uint } func main() { db, err := gorm.Open(&#34;sqlite3&#34;, &#34;test.db&#34;) if err != nil { panic(&#34;failed to connect database&#34;) } defer db.Close() // Migrate the schema  db.AutoMigrate(&amp;Product{}) // 创建  db.Create(&amp;Product{Code: &#34;L1212&#34;, Price: 1000}) // 读取  var product Product db.First(&amp;product, 1) // 查询id为1的product  db.First(&amp;product, &#34;code = ?
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=0001-01-01 itemprop="datePublished">January 1, 0001</time>
                </span>
                in
                
        </div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://lixiang-code.github.io/message-queue/"></a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 

       			
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=0001-01-01 itemprop="datePublished">January 1, 0001</time>
                </span>
                in
                
        </div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://lixiang-code.github.io/mysql%E7%AC%94%E8%AE%B0/"></a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 

       			MySql笔记 基本使用 DDL语句 1. 创建database
mysql&gt; create database test1; Query OK, 1 row affected (0.00 sec) 2. 查看datebase
mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | cluster | | mysql | | test | | test1 | +--------------------+ 5 rows in set (0.00 sec) 3. 使用database
mysql&gt; use mysql Database changed 4. 查看数据库所有表
mysql&gt; show tables; +---------------------------+ | Tables_in_mysql | +---------------------------+ | columns_priv | | db | | event | | func | | general_log | | help_category | | help_keyword | | help_relation | | help_topic | | host | | plugin | | proc | | procs_priv | | slow_log | | tables_priv | | time_zone | | time_zone_leap_second | | time_zone_name | | time_zone_transition | | time_zone_transition_type | | user | +---------------------------+ 21 rows in set (0.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=0001-01-01 itemprop="datePublished">January 1, 0001</time>
                </span>
                in
                
        </div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://lixiang-code.github.io/note/"></a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 

       			1.进程同步之信号量机制(PV操作) 1.1.信号量机制 信号量机制即利用pv操作对信号量进行处理.
什么是信号量?信号量(semaphore)的数据结构为一个值和一个指针,指针指向等待该信号量的下一个进程.信号量的值与相应资源的使用情况有关.
当它的值大于0时,表示当前可用资源的数量;
当它的值小于0时,其绝对值表示等待使用该资源的进程个数.
注意,信号量的值仅能由pv操作来改变.
一般来说，信号量S&gt;0时，S表示可用资源的数量。执行一次P操作意味着请求分配一个单位资源，因此S的值减1；当S&lt;0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个V操作意味着释放一个单位资源，因此S的值加1；若S=0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。
1.2.PV操作 什么是PV操作?
P操作(wait):申请一个单位资源,进程进入
经典伪代码:
wait(S){ while(s&lt;=0)	//如果没有资源则会循环等待； 	; S-- ; } V操作(signal):释放一个单位资源,进程出来
经典伪代码:
signal(S){ S++ ; } p操作（wait）：申请一个单位资源，进程进入
v操作（signal）：释放一个单位资源，进程出来
PV操作的含义：PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下： P（S）：①将信号量S的值减1，即S=S-1； ②如果S&lt;=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。 V（S）：①将信号量S的值加1，即S=S+1； ②如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。
PV操作的意义：我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信。
利用信号量和PV操作实现进程互斥的一般模型是： 进程P1 进程P2 …… 进程Pn …… …… …… P（S）； P（S）； P（S）； 临界区； 临界区； 临界区； V（S）； V（S）； V（S）； …… …… …… ……
其中信号量S用于互斥，初值为1。 使用PV操作实现进程互斥时应该注意的是： （1）每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。 （2）P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。 （3）互斥信号量的初值一般为1。
利用信号量和PV操作实现进程同步 PV操作是典型的同步机制之一。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。 使用PV操作实现进程同步时应该注意的是：
（1）分析进程间的制约关系，确定信号量种类。在保持进程间有正确的同步关系情况下，哪个进程先执行，哪些进程后执行，彼此间通过什么资源（信号量）进行协调，从而明确要设置哪些信号量。 （2）信号量的初值与相应资源的数量有关，也与P、V操作在程序代码中出现的位置有关。 （3）同一信号量的P、V操作要成对出现，但它们分别在不同的进程代码中。  1.3例题 1.生产者*-*消费者问题 在多道程序环境下，进程同步是一个十分重要又令人感兴趣的问题，而生产者*-*消费者问题是其中一个有代表性的进程同步问题。下面我们给出了各种情况下的生产者*-*消费者问题，深入地分析和透彻地理解这个例子，对于全面解决操作系统内的同步、互斥问题将有很大帮助。
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=0001-01-01 itemprop="datePublished">January 1, 0001</time>
                </span>
                in
                
        </div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://lixiang-code.github.io/smartbit/"></a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 

       			SmartBit 1.Qos 1. 1-2Port全速发包, 3Port收包, 查看包从哪个port发出,使用trigger step 1port des mac 为00:00:00:00:00:00:03 src mac 00:00:00:00:00:01 2port des mac 为00:00:00:00:00:00:03 src mac 00:00:00:00:00:02 
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=0001-01-01 itemprop="datePublished">January 1, 0001</time>
                </span>
                in
                
        </div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://lixiang-code.github.io/tcpreplay/"></a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 

       			Tcpreplay tcpreplay用于重放保存在pcap文件中的网络流量，它支持按照捕获pcap文件时数据包的速度、或者指定速度去重放网络流量，只要在硬件承受的范围内即可。
它可以根据需要，使流量可以在两个网卡直接拆分、写入文件、进行筛选、以各种方式进行编辑，从而为测试防火墙、NIDS和其他网络设备提供了方法。
格式：tcpreplay [-flags] [-flag [value]] [&ndash;option-name[[=| ]value]] &lt;pcap_file(s)&gt;
1、 命令参数： 　-d number, &ndash;dbug=number
启用调试输出。此选项最多可出现1次。此选项将整数作为参数。 number的值被限制为：在0到5的范围内 此选项的默认输入number为：0 如果使用&ndash;enable-debug进行配置，则可以为调试输出指定详细级别。数字越大，越详细。
　-q, &ndash;quiet
静默模式。除了运行结束时的统计数据外，不打印任何内容
　-T string, &ndash;timer=string
选择数据包计时模式：select，ioport，gtod，nano。此选项最多可出现1次。此选项的默认string是：gtod 允许您选择要使用的数据包计时方法：
nano - Use nanosleep() API
select - Use select() API
ioport - Write to the i386 IO Port 0x80
gtod [default] - Use a gettimeofday() loop
　&ndash;maxsleep=number
设置数据包之间休眠不超过X毫秒。此选项将整数作为参数。此选项的默认输入number为：0 设置tcpreplay在数据包之间休眠的最大毫秒数限制。有效防止数据包之间的长时间延迟，而不会影响大多数数据包。默认为禁用。
　-v, &ndash;verbose
通过tcpdump将解码后的数据包打印到标准输出。此选项最多可出现1次
　-A string, &ndash;decode=string
传递给tcpdump解码器的参数。此选项最多可出现1次。此选项必须与-v参数以前使用。 当启用详细模式（-v）时，您还可以指定一个或多个附加参数以传递给tcpdump来修改数据包的解码方式。默认情况下，使用-n和-l。确保string用双引号引起来，如：-A“-axxx”，否则会被tcpreplay作为参数误用。有关选项的完整列表，请参见tcpdump(1)手册页
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=0001-01-01 itemprop="datePublished">January 1, 0001</time>
                </span>
                in
                
        </div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://lixiang-code.github.io/vim/"></a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 

       			VIM    Version Change Description Author Date     1.0 vim基本使用方法 lixiang 2020/8/20                      1.安装 到http://172.22.102.206/documents/392下载cscope.shell, .vim和 .vimrc 拷贝.vim问价夹和.vimrc文件到用户根目录(~/) 在项目code目录及sdk目录执行脚本cscope.shell(也可以在项目根目录) 2.vim常用快捷键 2.1. 移动光标
​	基础移动:
h(左), j(下), k(上), l(右) ​	高级移动:
w (移动到下个单词开头) e (移动到单词尾) f+(char) (移动到当先行光标后的第一个char处) ​	借助插件移动光标(vim-easymotion)
​	是自己绑定的快捷键,目前是 ,
&lt;leader&gt;&lt;leader&gt;s+char(可视页面所有char位置) &lt;leader&gt;&lt;leader&gt;f+char(光标后可视char位置) &lt;leader&gt;&lt;leader&gt;w(光标后所有单词词首) &lt;leader&gt;&lt;leader&gt;e(光标后所有单词词尾) &lt;leader&gt;&lt;leader&gt;j(光标后所有行首) &lt;leader&gt;&lt;leader&gt;k(光标前所有行首) ​	重复操作
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=0001-01-01 itemprop="datePublished">January 1, 0001</time>
                </span>
                in
                
        </div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://lixiang-code.github.io/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"></a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 

       			工厂模式 1. 简单工厂模式 简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态（static）方法，因此简单工厂模式又被称为静态工厂方法（Static Factory Method）模式，它属于类创建型模式。 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计 例: 我们创建一个工厂结构体，并且创建一个产品接口，工厂可以创建产品，只要在工厂的某个方法中传入不同的参数，就可以返回实现产品接口的不同的对象
  创建工厂结构体
type Factory struct { }   创建产品接口
type Product interface { create() }   创建两个产品
// 产品1，实现产品接口 type Car struct { } func (c Car) create() { fmt.Println(&#34;this is car&#34;) } // 产品2，实现产品接口 type Bicycle struct { } func (b Bicycle) create() { fmt.Println(&#34;this is bicycle&#34;) }   为工厂结构添加一个方法用于生产产品(实例化对象)
func (f Factory) Generate(name string) Product { switch name { case &#34;car&#34;: return Car{} case &#34;bicycle&#34;: return Bicycle{} default: return nil } }   通过传入不同方法得到不同的产品示例
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=0001-01-01 itemprop="datePublished">January 1, 0001</time>
                </span>
                in
                
        </div>
				
			</div>
		</article>
	

	

<ul class="pagination">
    
    
    
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item ">
        <span class="page-link">
            <a href="/">1</a></li>
        </span>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active">
        <span class="page-link">
            <a href="/page/2/">2</a></li>
        </span>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item ">
        <span class="page-link">
            <a href="/page/3/">3</a></li>
        </span>
    
    
    
    
</ul>

</div>

  

          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>











    
    <script src="/js/vendor_main.min.js" async=""></script>



     </div>
  </body>
</html>
