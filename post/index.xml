<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hugo Blog</title>
    <link>/post/</link>
    <description>Recent content in Posts on Hugo Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright>
    <lastBuildDate>Sat, 30 Jan 2021 23:42:57 +0800</lastBuildDate>
    
	<atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>test</title>
      <link>/posts/test/</link>
      <pubDate>Sat, 30 Jan 2021 23:42:57 +0800</pubDate>
      
      <guid>/posts/test/</guid>
      <description>1.安装 到http://172.22.102.206/documents/392下载cscope.shell, .vim和 .vimrc 拷贝.vim问价夹和.vimrc文件到用户根目录(~/) 在项目code目录及sdk目录执行脚本cscope.shell(也可以在项目根目录) TODOhello lll </description>
    </item>
    
    <item>
      <title>Go Rpc</title>
      <link>/post/go-rpc/</link>
      <pubDate>Fri, 20 Mar 2020 21:09:01 +0800</pubDate>
      
      <guid>/post/go-rpc/</guid>
      <description>Rpc (Remote Procedure Call) 远程过程调用RPC, 就是客户端基于某种传输协议通过网络向服务提供端请求服务处理, 然后获取反回数据; 这种调用对于客户端而言和本地调用一样方便, 开发人员不需要了解具体的底层网络传输协议. 简单讲, 就是本地调用的逻辑处理的过程放在远程的机器上.
RPC架构 一般，远程过程调用RPC就是本地动态代理隐藏通信细节，通过组件序列化请求，走网络到服务端，执行真正的服务代码，然后将结果返回给客户端，反序列化数据给调用方法的过程。
RPC具体调用流程如下所示：
![RPC调用流程](/Users/lx/OneDrive - RLS ,inc/markdown/grpc-go-stack.png)
通用的RPC组件一般包括以下一些模块：
serviceClient：这个模块主要是封装服务端对外提供的API，让客户端像使用本地API接口一样调用远程服务。一般，我们使用动态代理机制，当客户端调用api的方法时，serviceClient会走代理逻辑，去远程服务器请求真正的执行方法，然后将响应结果作为本地的api方法执行结果返回给客户端应用。类似RMI的stub模块。 processor：在服务端存在很多方法，当客户端请求过来，服务端需要定位到具体对象的具体方法，然后执行该方法，这个功能就由processor模块来完成。一般这个操作需要使用反射机制来获取用来执行真实处理逻辑的方法，当然，有的RPC直接在server初始化的时候，将一定规则写进Map映射中，这样直接获取对象即可。类似RMI的skeleton模块。 protocol：协议层，这是每个RPC组件的核心技术所在。一般，协议层包括编码/解码，或者说序列化和反序列化工作；当然，有的时候编解码不仅仅是对象序列化的工作，还有一些通信相关的字节流的额外解析部分。序列化工具有：hessian，protobuf，avro,thrift，json系，xml系等等。在RMI中这块是直接使用JDK自身的序列化组件。 transport：传输层，主要是服务端和客户端网络通信相关的功能。这里和下面的IO层区分开，主要是因为传输层处理server/client的网络通信交互，而不涉及具体底层处理连接请求和响应相关的逻辑。 I/O：这个模块主要是为了提高性能可能采用不同的IO模型和线程模型，当然，一般我们可能和上面的transport层联系的比较紧密，统一称为remote模块。 此外，还有业务代码自己去实现的client和server层。client当需要远程调用服务时，会首先初始化一个API接口代理对象，然后调用某个代理方法。server在对外暴露服务时，需要首先实现对应API接口内部的方法，当请求过来时，通过反射找到对应的实例对象，执行对应的业务代码。
![img](/Users/lx/OneDrive - RLS ,inc/markdown/rpc框架.png)
JSON-RPC 1.JSON-RPC介绍 JSON-RPC是一个无状态且轻量级的RPC协议，其传输内容以JSON方式，相对于一般的HTTP请求通过URI调用远程服务器，JSON-RPC直接在内容中定义了要调用的函数名称（如 {“method”: “getUser”}），对于开发者来说非常的方便。Bitcoin和Ethereum都支持JSON-RPC通过客户端直接调用节点上的函数或方法。 注意: 以rpc开头的方法名预留作为系统扩展，且必须不能用于其他地方。
2.约定 由于JSON-RPC使用JSON，它具有与其相同的类型系统(见http://www.json.org或RFC 4627)。JSON可以表示四个基本类型(String、Numbers、Booleans和Null)和两个结构化类型(Objects和Arrays)。 规范中，术语“Primitive”标记那4种原始类型，“Structured”标记两种结构化类型。任何时候文档涉及JSON数据类型，第一个字母都必须大写：Object，Array，String，Number，Boolean，Null。包括True和False也要大写。
在客户端与任何被匹配到的服务端之间交换的所有成员名字应是区分大小写的。 函数、方法、过程都可以认为是可以互换的。
客户端被定义为请求对象的来源及响应对象的处理程序。
服务端被定义为响应对象的起源和请求对象的处理程序。
该规范的一种实现为可以轻而易举的填补这两个角色,即使是在同一时间,同一客户端或其他不相同的客户端。 该规范不涉及复杂层。
3.JSON-RPC请求 JSON-RPC 2.0和1.0之间一些差异，我们这里介绍2.0的使用，一个JSON-RPC的请求必须包含以下4个字段。
1.jsonrpc: 指定JSON-RPC的版本，必须设置为2.0 2.id: 已建立客户端的唯一标识id，值必须包含一个字符串、数值或NULL空值。如果不包含该成员则被认定为是一个通知。该值一般不为NULL，若为数值则不应该包含小数。 3.method: 包含所要调用方法名称的字符串，以rpc开头的方法名，用英文句号连接的为预留给rpc内部的方法名及扩展名，且不能在其他地方使用。 4.params: 方法传入的参数，若无参数则传入空[] 4.JSON-RPC响应 当发起一个RPC调用时，除通知之外服务端都必须有响应，响应表示为一个JSON对象包含以下几个字段。
1.jsonrpc: 指定JSON-RPC的版本，固定为为2.0 2.id: 调用标识符，用于标示一次远程调用过程，值必须包含一个字符串、数值。 3.result: 如果调用成功则显示响应结果 4.error: 如果调用失败则显示错误的信息，error带有以下几个字段 4.1.code: 使用数值表示该异常的错误类型，必须为整数 【必须】 4.</description>
    </item>
    
    <item>
      <title>Go Rpc</title>
      <link>/posts/go-rpc/</link>
      <pubDate>Fri, 20 Mar 2020 21:09:01 +0800</pubDate>
      
      <guid>/posts/go-rpc/</guid>
      <description>Rpc (Remote Procedure Call) 远程过程调用RPC, 就是客户端基于某种传输协议通过网络向服务提供端请求服务处理, 然后获取反回数据; 这种调用对于客户端而言和本地调用一样方便, 开发人员不需要了解具体的底层网络传输协议. 简单讲, 就是本地调用的逻辑处理的过程放在远程的机器上.
RPC架构 一般，远程过程调用RPC就是本地动态代理隐藏通信细节，通过组件序列化请求，走网络到服务端，执行真正的服务代码，然后将结果返回给客户端，反序列化数据给调用方法的过程。
RPC具体调用流程如下所示：
![RPC调用流程](/Users/lx/OneDrive - RLS ,inc/markdown/grpc-go-stack.png)
通用的RPC组件一般包括以下一些模块：
serviceClient：这个模块主要是封装服务端对外提供的API，让客户端像使用本地API接口一样调用远程服务。一般，我们使用动态代理机制，当客户端调用api的方法时，serviceClient会走代理逻辑，去远程服务器请求真正的执行方法，然后将响应结果作为本地的api方法执行结果返回给客户端应用。类似RMI的stub模块。 processor：在服务端存在很多方法，当客户端请求过来，服务端需要定位到具体对象的具体方法，然后执行该方法，这个功能就由processor模块来完成。一般这个操作需要使用反射机制来获取用来执行真实处理逻辑的方法，当然，有的RPC直接在server初始化的时候，将一定规则写进Map映射中，这样直接获取对象即可。类似RMI的skeleton模块。 protocol：协议层，这是每个RPC组件的核心技术所在。一般，协议层包括编码/解码，或者说序列化和反序列化工作；当然，有的时候编解码不仅仅是对象序列化的工作，还有一些通信相关的字节流的额外解析部分。序列化工具有：hessian，protobuf，avro,thrift，json系，xml系等等。在RMI中这块是直接使用JDK自身的序列化组件。 transport：传输层，主要是服务端和客户端网络通信相关的功能。这里和下面的IO层区分开，主要是因为传输层处理server/client的网络通信交互，而不涉及具体底层处理连接请求和响应相关的逻辑。 I/O：这个模块主要是为了提高性能可能采用不同的IO模型和线程模型，当然，一般我们可能和上面的transport层联系的比较紧密，统一称为remote模块。 此外，还有业务代码自己去实现的client和server层。client当需要远程调用服务时，会首先初始化一个API接口代理对象，然后调用某个代理方法。server在对外暴露服务时，需要首先实现对应API接口内部的方法，当请求过来时，通过反射找到对应的实例对象，执行对应的业务代码。
![img](/Users/lx/OneDrive - RLS ,inc/markdown/rpc框架.png)
JSON-RPC 1.JSON-RPC介绍 JSON-RPC是一个无状态且轻量级的RPC协议，其传输内容以JSON方式，相对于一般的HTTP请求通过URI调用远程服务器，JSON-RPC直接在内容中定义了要调用的函数名称（如 {“method”: “getUser”}），对于开发者来说非常的方便。Bitcoin和Ethereum都支持JSON-RPC通过客户端直接调用节点上的函数或方法。 注意: 以rpc开头的方法名预留作为系统扩展，且必须不能用于其他地方。
2.约定 由于JSON-RPC使用JSON，它具有与其相同的类型系统(见http://www.json.org或RFC 4627)。JSON可以表示四个基本类型(String、Numbers、Booleans和Null)和两个结构化类型(Objects和Arrays)。 规范中，术语“Primitive”标记那4种原始类型，“Structured”标记两种结构化类型。任何时候文档涉及JSON数据类型，第一个字母都必须大写：Object，Array，String，Number，Boolean，Null。包括True和False也要大写。
在客户端与任何被匹配到的服务端之间交换的所有成员名字应是区分大小写的。 函数、方法、过程都可以认为是可以互换的。
客户端被定义为请求对象的来源及响应对象的处理程序。
服务端被定义为响应对象的起源和请求对象的处理程序。
该规范的一种实现为可以轻而易举的填补这两个角色,即使是在同一时间,同一客户端或其他不相同的客户端。 该规范不涉及复杂层。
3.JSON-RPC请求 JSON-RPC 2.0和1.0之间一些差异，我们这里介绍2.0的使用，一个JSON-RPC的请求必须包含以下4个字段。
1.jsonrpc: 指定JSON-RPC的版本，必须设置为2.0 2.id: 已建立客户端的唯一标识id，值必须包含一个字符串、数值或NULL空值。如果不包含该成员则被认定为是一个通知。该值一般不为NULL，若为数值则不应该包含小数。 3.method: 包含所要调用方法名称的字符串，以rpc开头的方法名，用英文句号连接的为预留给rpc内部的方法名及扩展名，且不能在其他地方使用。 4.params: 方法传入的参数，若无参数则传入空[] 4.JSON-RPC响应 当发起一个RPC调用时，除通知之外服务端都必须有响应，响应表示为一个JSON对象包含以下几个字段。
1.jsonrpc: 指定JSON-RPC的版本，固定为为2.0 2.id: 调用标识符，用于标示一次远程调用过程，值必须包含一个字符串、数值。 3.result: 如果调用成功则显示响应结果 4.error: 如果调用失败则显示错误的信息，error带有以下几个字段 4.1.code: 使用数值表示该异常的错误类型，必须为整数 【必须】 4.</description>
    </item>
    
    <item>
      <title>药师灌顶真言</title>
      <link>/posts/chinese-preview/</link>
      <pubDate>Thu, 11 Apr 2019 14:26:00 +0800</pubDate>
      
      <guid>/posts/chinese-preview/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;修学药师灌顶真言是药师法门的一部分，读诵修持有着极大的功德利益&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;内容&#34;&gt;内容&lt;/h1&gt;
&lt;p&gt;南无薄伽伐帝鞞杀社&lt;/p&gt;
&lt;p&gt;窭噜薜琉璃&lt;/p&gt;
&lt;p&gt;跋喇婆&lt;/p&gt;
&lt;p&gt;喝啰阇也&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>日本語敬語体系</title>
      <link>/posts/japanese-preview/</link>
      <pubDate>Wed, 10 Apr 2019 14:26:00 +0800</pubDate>
      
      <guid>/posts/japanese-preview/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;日本語の敬語体系は、一般に、大きく尊敬語・謙譲語・丁寧語に分類される。文化審議会国語分科会は、2007年2月に「敬語の指針」を答申し、これに丁重語および美化語を含めた5分類を示している。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;尊敬語&#34;&gt;尊敬語&lt;/h1&gt;
&lt;p&gt;尊敬語は、動作の主体を高めることで、主体への敬意を表す言い方である。動詞に「お（ご）～になる」を付けた形、また、助動詞「（ら）れる」を付けた形などが用いられる。たとえば、動詞「取る」の尊敬形として、「（先生が）お取りになる」「（先生が）取られる」などが用いられる。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>/posts/english-preview/</link>
      <pubDate>Mon, 01 Apr 2019 14:26:00 +0800</pubDate>
      
      <guid>/posts/english-preview/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Theme Preview</title>
      <link>/posts/theme-preview/</link>
      <pubDate>Sun, 31 Mar 2019 17:49:40 +0800</pubDate>
      
      <guid>/posts/theme-preview/</guid>
      <description>&lt;h1 id=&#34;headings&#34;&gt;Headings&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;# H1
&lt;span style=&#34;color:#75715e&#34;&gt;## H2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;### H3
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#### H4
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;##### H5
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;###### H6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>The &#34;figure&#34; Shortcode</title>
      <link>/posts/the-figure-shortcode/</link>
      <pubDate>Mon, 24 Dec 2018 12:29:41 +0800</pubDate>
      
      <guid>/posts/the-figure-shortcode/</guid>
      <description>Hugo has figure shortcode built in, so you can easily add figcaptions or hyperlink rel attributes to images. Documentations can be found here:
https://gohugo.io/content-management/shortcodes/#figure
This theme has 3 CSS classes made for figure elements:
 big: images will break the width limit of main content area. left: images will float to the left. right: images will float to the right.  If a figure has no class set, the image will behave just like a normal markdown image: !</description>
    </item>
    
    <item>
      <title>vim guide</title>
      <link>/posts/vim/</link>
      <pubDate>Mon, 24 Dec 2018 12:29:41 +0800</pubDate>
      
      <guid>/posts/vim/</guid>
      <description>VIM    Version Change Description Author Date     1.0 vim基本使用方法 lixiang 2020/8/20                      1.安装 到http://172.22.102.206/documents/392下载cscope.shell, .vim和 .vimrc 拷贝.vim问价夹和.vimrc文件到用户根目录(~/) 在项目code目录及sdk目录执行脚本cscope.shell(也可以在项目根目录) 2.vim常用快捷键 2.1. 移动光标
​	基础移动:
h(左), j(下), k(上), l(右) ​	高级移动:
w (移动到下个单词开头) e (移动到单词尾) f+(char) (移动到当先行光标后的第一个char处) ​	借助插件移动光标(vim-easymotion)
​	是自己绑定的快捷键,目前是 ,
&amp;lt;leader&amp;gt;&amp;lt;leader&amp;gt;s+char(可视页面所有char位置) &amp;lt;leader&amp;gt;&amp;lt;leader&amp;gt;f+char(光标后可视char位置) &amp;lt;leader&amp;gt;&amp;lt;leader&amp;gt;w(光标后所有单词词首) &amp;lt;leader&amp;gt;&amp;lt;leader&amp;gt;e(光标后所有单词词尾) &amp;lt;leader&amp;gt;&amp;lt;leader&amp;gt;j(光标后所有行首) &amp;lt;leader&amp;gt;&amp;lt;leader&amp;gt;k(光标前所有行首) ​	重复操作</description>
    </item>
    
    <item>
      <title>Post With Featured Image</title>
      <link>/posts/post-with-featured-image/</link>
      <pubDate>Mon, 01 Oct 2018 16:15:09 +0800</pubDate>
      
      <guid>/posts/post-with-featured-image/</guid>
      <description>Just define the image URL in the content’s front matter, the featured image will be displayed as the background.
For example:
--- images: - https://picsum.photos/1024/768/?random --- This is an array, you can set multiple urls, only the first url will be used. These images is also used in Twitter Cards and the Open Graph metadata.</description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>/post/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>/post/creating-a-new-theme/</guid>
      <description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>/posts/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>/posts/creating-a-new-theme/</guid>
      <description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>/post/goisforlovers/</link>
      <pubDate>Mon, 28 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>/post/goisforlovers/</guid>
      <description>Hugo uses the excellent go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in go templates.
This document is a brief primer on using go templates.</description>
    </item>
    
    <item>
      <title>Hugo 主题 Nuo 文章样式预览</title>
      <link>/post/hugo-nuo-post-preview/</link>
      <pubDate>Thu, 17 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>/post/hugo-nuo-post-preview/</guid>
      <description>&lt;p&gt;这篇文章集中说明本人博客主题所支持的 Markdown 语法和 Hugo Shortcodes 插件，你也可以在这里预览到他们的样子。如果你不喜欢某些部分的样式，可以去修改 &lt;code&gt;content.scss&lt;/code&gt; 和 &lt;code&gt;shortcodes.scss&lt;/code&gt; 这两个文件。预告一下，我所用的这个名为 &lt;code&gt;Nuo&lt;/code&gt; 的 &lt;code&gt;Hugo&lt;/code&gt; 也将于近期发布，敬请期待。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>/post/hugoisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>/post/hugoisforlovers/</guid>
      <description>Step 1. Install Hugo Goto hugo releases and download the appropriate version for your os and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at installing hugo
Step 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:
 Clone the hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>/posts/hugoisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>/posts/hugoisforlovers/</guid>
      <description>Step 1. Install Hugo Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:
 Clone the Hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:</description>
    </item>
    
    <item>
      <title>Migrate to Hugo from Jekyll</title>
      <link>/post/migrate-from-jekyll/</link>
      <pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>/post/migrate-from-jekyll/</guid>
      <description>Move static content to static Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png  should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png  Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description>
    </item>
    
  </channel>
</rss>